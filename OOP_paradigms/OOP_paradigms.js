//---------------------------------------
//__Процедурный функциональный подход__//
//получения аргментов для работы
//выполнения функций
//возвращения результата

//Проблема
//большое количество кода
//сложность организации
//сложность декомпозиции и разделения логики

function calculateSquareArea(sideLength) {
  return sideLength * sideLength;
}

function calculateCircleArea(radius) {
  return Math.PI * radius * radius;
}

function calculateTriangleArea(base, height) {
  return (base * height) / 2;
}

const sideLength = 5;
const radius = 3;
const base = 4;
const height = 6;

const squareArea = calculateSquareArea(sideLength);
const circleArea = calculateCircleArea(radius);
const triangleArea = calculateTriangleArea(base, height);

console.log(squareArea); // Вывод: 25
console.log(circleArea); // Вывод: 28.274333882308138
console.log(triangleArea); // Вывод: 12

//В целом, процедурный функциональныйподход имеет свои ограничения, особенно при разработке сложных программ. Он может столкнуться с проблемами масштабируемости, поддержки и понимания кода. Для решения этих проблем часто используются другие парадигмы программирования, такие как объектно-ориентированное программирование (ООП) или функциональное программирование (ФП), которые предоставляют более структурированные и гибкие подходы к разработке программ.

//---------
//__ООП__//
//В результате появилось ООП
//любую структуру можно представить в виде класса

//__Объект 
// Объект является элементарной единицей в объектно - ориентированном программировании(ООП).Он представляет собой сущность, которая имеет свойства(данные) и методы(функции), связанные с этой сущностью.Объекты создаются на основе классов, которые определяют их структуру и поведение.
const person = {
  name: 'John',
  age: 30,
  city: 'New York',
  getDetails() {
    return `${this.name} is ${this.age} years old and lives in ${this.city}.`;
  }
};

console.log(person.name); // Вывод: John
console.log(person.age); // Вывод: 30
console.log(person.city); // Вывод: New York
console.log(person.getDetails()); // Вывод: John is 30 years old and lives in New York.

//-----------
//__Класс__//
//Классы включают в себя описания структуры и поведения объектов, а также определяют набор свойств и методов, которые будут доступны для каждого созданного объекта

//Классы создаются с использованием ключевого слова class, за которым следует имя класса. Внутри класса можно определить конструктор, методы и другие компоненты.
class MyClass {
  // Компоненты класса
}

//Конструктор - это специальный метод, который вызывается при создании нового объекта на основе класса. Он инициализирует свойства объекта и выполняет другие необходимые операции. Конструктор определяется с помощью метода constructor.
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}

//Свойства представляют данные объекта и хранят информацию о состоянии объекта. Они объявляются внутри класса и могут быть инициализированы в конструкторе или иметь значения по умолчанию
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
    this.city = 'New York'; // Свойство с значением по умолчанию
  }
}

//Методы представляют функциональность объекта и выполняют действия над данными объекта. Они объявляются внутри класса и могут получать доступ к свойствам объекта через ключевое слово this.
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  greet() {
    console.log(`Hello, my name is ${this.name} and I'm ${this.age} years old.`);
  }
}

//Чтобы создать объект на основе класса, используется ключевое слово new, за которым следует имя класса и аргументы, передаваемые в конструктор класса.
const person = new Person('John', 30);
person.greet(); // Вывод: Hello, my name is John and I'm 30 years old.

//Классы позволяют создавать множество объектов с общими характеристиками и функциональностью. Они обеспечивают модульность, инкапсусуляцию и повторное использование кода

//-------------------
//__Концепции ООП__//

//__Наследование
//Наследование позволяет создавать новый класс на основе существующего класса, называемого родительским или базовым классом. Новый класс, называемый дочерним или производным классом, наследует свойства и методы родительского класса и может добавлять свои собственные свойства и методы. Наследование способствует повторному использованию кода, расширению функциональности и созданию иерархии классов.

// Родительский класс
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  greet() {
    console.log(`Привет, меня зовут ${this.name} и мне ${this.age} лет.`);
  }
}

// Дочерний класс
class Student extends Person {
  constructor(name, age, major) {
    // Вызываем конструктор родительского класса
    super(name, age);

    this.major = major;
  }

  study() {
    console.log(`${this.name} изучает ${this.major}.`);
  }
}

// Создаем объект дочернего класса
const student = new Student("Джон", 20, "Компьютерные науки");

// Вызываем методы родительского и дочернего классов
student.greet(); // Привет, меня зовут Джон и мне 20 лет.
student.study(); // Джон изучает Компьютерные науки.

//__Инкапсуляция
//позволяет скрывать внутреннее состояние объекта и контролировать доступ к нему извне

// Класс с приватными свойствами и методами
class Person {
  #name; // Приватное свойство
  #age; // Приватное свойство

  constructor(name, age) {
    this.#name = name;
    this.#age = age;
  }

  // Геттер для получения приватного свойства #name
  get name() {
    return this.#name;
  }

  // Сеттер для изменения приватного свойства #name
  set name(newName) {
    this.#name = newName;
  }

  // Публичный метод для вывода информации о человеке
  greet() {
    console.log(`Привет, меня зовут ${this.#name} и мне ${this.#age} лет.`);
  }
}

// Создаем объект класса Person
const person = new Person("Джон", 20);

// Получаем доступ к приватному свойству #name с помощью геттера
console.log(person.name); // Джон

// Изменяем приватное свойство #name с помощью сеттера
person.name = "Джейн";

// Вызываем публичный метод greet()
person.greet(); // Привет, меня зовут Джейн и мне 20 лет.

//__Полиморфизм:
//Полиморфизм позволяет объектам одного класса использовать методы, определенные в другом классе, совершенно различным образом.Это означает, что один и тот же метод может иметь различную реализацию в разных классах.

// Переопределение методов
// Переопределение методов позволяет дочерним классам предоставлять свою собственную реализацию методов, унаследованных от родительского класса.Это означает, что один и тот же метод может вести себя по - разному для разных объектов, в зависимости от их типа.
// Родительский класс
class Animal {
  makeSound() {
    console.log("Животное издает звук");
  }
}

// Дочерний класс
class Dog extends Animal {
  makeSound() {
    console.log("Собака лает");
  }
}

// Дочерний класс
class Cat extends Animal {
  makeSound() {
    console.log("Кошка мяукает");
  }
}

// Создаем объекты дочерних классов
const dog = new Dog();
const cat = new Cat();

// Вызываем метод makeSound() для каждого объекта
dog.makeSound(); // Собака лает
cat.makeSound(); // Кошка мяукает

//__Интерфейс
//Интерфейс в объектно - ориентированном программировании(ООП) - это контракт, который определяет набор методов и свойств, которые должен реализовать класс.Интерфейсы не содержат фактической реализации методов, а только их сигнатуры.

//Этот интерфейс определяет метод makeSound(), который должен быть реализован любым классом, реализующим интерфейс Animal
interface Animal {
  makeSound(): void;
}

//__Абстракция
//Абстракция - это процесс сокрытия деталей реализации и предоставления только необходимого интерфейса

//Абстрактный класс может содержать как абстрактные, так и неабстрактные методы, в то время как интерфейс содержит только абстрактные методы.

//Абстрактный класс может иметь конструктор и поля, в то время как интерфейс не может

//Абстрактные классы используются для определения общего поведения для набора связанных классов, в то время как интерфейсы используются для определения контрактов, которым должны следовать классы

abstract class Animal {
  constructor(name) {
    this.name = name;
  }

  abstract makeSound(): void;
  abstract eat(): void;
}

class Dog extends Animal {
  constructor(name) {
    super(name);
  }

  makeSound() {
    console.log(`${this.name} лает`);
  }

  eat() {
    console.log(`${this.name} ест корм для собак`);
  }
}
const dog = new Dog("Рекс");
dog.makeSound(); // Рекс лает
dog.eat(); // Рекс ест корм для собак

//__Композиция
// Заключается в создании объектов, которые содержат другие объекты в качестве своих членов. Это позволяет создавать сложные объекты из более простых, повторно используя существующий код и повышая гибкость

// Класс автомобиля
class Car {
  constructor(engine, wheels) {
    this.engine = engine;
    this.wheels = wheels;
  }

  drive() {
    console.log("Машина едет");
  }
}

// Класс двигателя
class Engine {
  constructor(power) {
    this.power = power;
  }

  start() {
    console.log("Двигатель запущен");
  }
}

// Класс колеса
class Wheel {
  constructor(size) {
    this.size = size;
  }

  roll() {
    console.log("Колесо катится");
  }
}

// Создаем объекты двигателя и колес
const engine = new Engine(200);
const wheels = [new Wheel(16), new Wheel(16), new Wheel(16), new Wheel(16)];

// Создаем объект автомобиля с помощью композиции
const car = new Car(engine, wheels);

// Вызываем методы автомобиля
car.drive(); // Машина едет
car.engine.start(); // Двигатель запущен
car.wheels[0].roll(); // Колесо катится

//__Агрегация
//Агрегация - это принцип объектно-ориентированного программирования (ООП), который заключается в создании объектов, которые содержат ссылки на другие объекты, но не владеют ими. Это позволяет создавать отношения "часть-целое", где целое может существовать независимо от своих частей.
// Класс университета
class University {
  constructor(name, departments) {
    this.name = name;
    this.departments = departments;
  }

  addDepartment(department) {
    this.departments.push(department);
  }
}

// Класс факультета
class Department {
  constructor(name, courses) {
    this.name = name;
    this.courses = courses;
  }

  addCourse(course) {
    this.courses.push(course);
  }
}

// Класс курса
class Course {
  constructor(name) {
    this.name = name;
  }
}

// Создаем объекты факультетов и курсов
const department1 = new Department("Факультет информатики", []);
const department2 = new Department("Факультет экономики", []);

const course1 = new Course("Программирование на JavaScript");
const course2 = new Course("Экономика предприятия");

// Создаем объект университета с помощью агрегации
const university = new University("Университет", [department1, department2]);

// Добавляем курсы в факультеты
department1.addCourse(course1);
department2.addCourse(course2);

// Выводим информацию об университете
console.log(university.name); // Университет
console.log(university.departments); // [Факультет информатики, Факультет экономики]