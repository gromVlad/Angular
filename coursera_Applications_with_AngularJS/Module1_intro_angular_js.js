//__Цель Angular и подобных фреймворков

// Фреймворки, такие как Angular, предназначены для решения проблемы растущей сложности кода по мере добавления функциональности в проект. Без таких подходов код становится сложным сам по себе.

// Характеристики управляемого кода
// Организация: Код должен быть организован таким образом, чтобы легко находить фрагменты, отвечающие за определенную функциональность.
// Модульность: Изменения в коде должны влиять только на затронутые модули, а не на весь код.
// Повторное использование: Похожая функциональность должна быть реализована в одном месте, чтобы избежать дублирования и ошибок.
// Тестируемость: Код должен быть написан таким образом, чтобы его можно было легко тестировать небольшими фрагментами без необходимости запуска всей системы.

// Преимущества управляемого код
// Удобство для новых разработчиков
// Гибкость при изменении требований
// Экономия времени за счет отсутствия дублирования
// Уменьшение ошибок за счет централизованного обновления кода

//----------------------------
//__Причины сложности кода__//

// Плохая читаемость: несогласованный стиль кодирования, запутанные имена функций и переменных, отсутствие комментариев и документации.

// Низкая сплоченность и высокая связанность:
// Сплоченность - степень взаимосвязи элементов кода внутри одного модуля. Высокая сплоченность означает, что элементы тесно связаны и выполняют одну задачу.
// Связанность - степень зависимости одного модуля от других. Низкая связанность означает, что модули слабо зависят друг от друга и могут легко изменяться без влияния на другие модули.

// Примеры низкой сплоченности и высокой связанности
// Низкая сплоченность: Расписание человека, содержащее различные и не связанные задачи.
// Высокая связанность: Расписание компьютера, состоящее из тесно связанных задач (включение, запуск ОС, выключение).

// Преимущества низкой связанности
// Упрощает разработку, так как не нужно учитывать всю систему при изменении одного модуля.
// Пример низкой связанности в реальной жизни: замена батареи в LG G5 (простая операция) по сравнению с заменой батареи в iPhone (сложная операция).

// Улучшенный дизайн
// Чтобы улучшить дизайн, следует разделить функциональность на более мелкие и сплоченные компоненты

//----------------------------------------------------------
//__Model-View-ViewModel__//

// MVVM (Model-View-ViewModel) - это шаблон проектирования, который разделяет приложение на три основных компонента:
// Модель: Содержит и управляет необработанными данными приложения.
// Представление (View): Пользовательский интерфейс, отображающий данные из модели.
// Модель представления (ViewModel): Посредник между моделью и представлением.
// Как работает MVVM

// Модель предоставляет данные приложению.
// ViewModel получает данные из модели и преобразует их в формат, подходящий для представления.
// Представление отображает данные из ViewModel.
// Когда пользователь взаимодействует с представлением (например, нажимает кнопку), представление отправляет событие ViewModel.
// ViewModel обрабатывает событие и обновляет модель в соответствии с действиями пользователя.
// Модель обновляет свои данные.
// ViewModel получает обновленные данные из модели и обновляет представление.
// Преимущества MVVM

// Высокая сплоченность: Компоненты MVVM имеют четко определенные роли и не выполняют несвязанных задач.
// Низкая связанность: Изменения в представлении не влияют на модель представления и наоборот.
// Упрощенная разработка: Декларативный связыватель автоматизирует обновление представления, снижая количество кода для написания.
// Простым языком

// Представьте, что у вас есть приложение для списка покупок.
// Модель: Это ваш список покупок с элементами, такими как "яблоки", "молоко" и "хлеб".
// ViewModel: Это список покупок, который отображается на экране. Он получает элементы из модели и преобразует их в формат, который может отображаться в представлении.
// Представление: Это пользовательский интерфейс, который показывает список покупок. Он получает элементы из ViewModel и отображает их на экране.
// Когда вы добавляете новый элемент в список покупок, вы взаимодействуете с представлением. Представление отправляет событие ViewModel, который обновляет модель. Затем ViewModel обновляет представление, чтобы отобразить новый элемент в списке.

// MVVM помогает разделить приложение на отдельные компоненты, которые легко понять и поддерживать. Это также упрощает тестирование и повторное использование кода.

//---------------------------
//__Пример кода AngularJS__//

/* 
<!DOCTYPE html>
//ng-app - связывает модуль myFirstApp с элементом DOM
<html lang="en" ng-app="myFirstApp">
<head >
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="angular.min.js"></script>
    <script src="app.model.js"></script>
</head>
<body>
    //ng-controller="MyFirstController" связывает контроллер MyFirstController с элементом DOM
    <div ng-controller="MyFirstController">
        <!-- Содержимое, управляемое контроллером -->
    </div>
</body>
</html>
*/
//app.model.js
(function () {
    'use strict';

    angular.module('myFirstApp', [])
        //Функция MyFirstController определяет функциональность контроллера
        .controller('MyFirstController', function () {
            // Функциональность контроллера
        });
})();

//-----------------------------------
//__Связывание данных в AngularJS__//

/* 
<div ng-controller="MyFirstController">
        <h1>{{ name }}</h1>

        //ng-model="name" связывает значение поля ввода с $scope.name.
        <input ng-model="name" type="text" />

        <p>Inside my input is {{ name }}</p>

        //вызывает функцию sayHello и отображает ее результат в представлении.
        <p>{{ sayHello() }}</p>
</div>
*/
(function () {
    'use strict';
    angular.module('myFirstApp', [])
        // AngularJS предоставляет объект $scope для связывания данных между моделью представления (контроллером) и представлением (HTML). Свойства, определенные на $scope, доступны в представлении.
        .controller('MyFirstController', function ($scope) {
            $scope.name = 'Yaakov';

            $scope.sayHello = function () {
                return 'Hello Coursera!';
            };
        });
})();

//----------------------------------
//__Exploer CalculatorController__//
/* 
<body ng-app="NameCalculator">
    <div ng-controller="NameCalculatorController">
        <h1>Name Calculator</h1>

        //Событие keyup срабатывает, когда пользователь отпускает клавишу на клавиатуре
        <input type="text" ng-model="name" ng-keyup="displayNumeric()">

        <p>Total numeric value of person's name: {{totalValue}}</p>
    </div>
</body>
*/
(function () {
    'use strict';
    angular.module('NameCalculator', [])
        .controller('NameCalculatorController', function ($scope) {
            $scope.name = '';
            $scope.totalValue = 0;

            $scope.displayNumeric = function () {
                var totalNameValue = calculateNumericForString($scope.name);
                $scope.totalValue = totalNameValue;
            };

            function calculateNumericForString(string) {
                var total = 0;
                for (var i = 0; i < string.length; i++) {
                    total += string.charCodeAt(i);
                }
                return total;
            }
        });
})();

//----------------------------------------------------------------
//__Что скрывается за "магией": Пользовательские атрибуты HTML__//

// Связывание ng-app
// AngularJS использует querySelector для поиска элемента с атрибутом ng-app.
// Значение атрибута ng-app используется для поиска соответствующего модуля AngularJS.
// Модуль AngularJS связывается с элементом и всем его содержимым.

// Получение элемента с атрибутом ng-app
var element = document.querySelector('[ng-app]');

// Получение значения атрибута ng-app
var appModuleName = element.getAttribute('ng-app');

//---------------------------
//__Инъекция зависимостей__//

/* 
Концепция внедрения зависимостей

AngularJS использует внедрение зависимостей, которое является шаблоном проектирования для разрешения зависимостей.
Внедрение зависимостей реализует инверсию управления, которая представляет собой подход к разрешению зависимостей.
Инверсия управления

Обычно модули зависят от других модулей (например, модуль корзины покупок зависит от модуля обработки кредитных карт).
При инверсии управления клиент (модуль корзины покупок) получает зависимости (модуль обработки кредитных карт) от внешней системы (AngularJS).
Это устраняет жесткую связь между модулями и упрощает тестирование.
Внедрение зависимостей в AngularJS

AngularJS создает объект $scope, который является сложным объектом, используемым для связи между контроллером и представлением.
Внедрение зависимостей позволяет контроллеру получить объект $scope в качестве аргумента.
AngularJS является внешней системой, которая вызывает клиент (контроллер) и предоставляет зависимости (объект $scope).
Преимущества внедрения зависимостей

Устранение жесткой связи между модулями.
Упрощение тестирования.
Повышение гибкости и масштабируемости.
*/

//----------------------------------------------------
//__Как работает Dependency Injection в Javascript__//

//AngularJS использует инъекцию зависимостей для динамического предоставления зависимостей (сервисов) контроллерам.

//Сервисы в AngularJS обозначаются префиксом "$".Сервисы внедряются в контроллеры в качестве аргументов функции контроллера.

app.controller('DIController', function ($scope, $filter) {
    $scope.upper = function () {
        $scope.name = $filter('uppercase')($scope.name);
    };
});

//Как AngularJS определяет, какие зависимости внедрять
//AngularJS использует сервис $injector для определения зависимостей, необходимых для функции контроллера.
//$injector анализирует строковое представление функции контроллера и извлекает имена аргументов.
//Затем $injector сопоставляет имена аргументов с доступными сервисами и внедряет соответствующие сервисы в контроллер.

function DIController($scope, $filter) {
    // ...
}

console.log($injector.annotate(DIController)); // ['scope', 'filter']\

//-------------------------------------------------
//__Защита инъекции зависимостей от минификации__//

//Минимизация - это процесс удаления ненужных символов из исходного кода без изменения его функциональности

//Минимизация может нарушить внедрение зависимостей в AngularJS, удаляя имена переменных, которые Angular использует для определения, что внедрять.

//$inject свойство: Добавьте свойство $inject к функции контроллера, которое содержит массив имен зависимостей. Angular будет использовать этот массив для внедрения зависимостей.

// До минимизации
app.controller('DIController', function ($scope, $filter) {
    // Код контроллера
});

// После минимизации
app.controller('N', ['$scope', '$filter', function ($scope, $filter) {
    // Код контроллера
}]);

// С использованием $inject свойства - используем в приоритетную очередь
app.controller('DIController', function ($scope, $filter) {
    DIController.$inject = ['$scope', '$filter'];
    // Код контроллера
});

//------------------------------
//__Выражения и интерполяция__//

//Интерполяция - это процесс замены заполнителей в строке реальными значениями.
//В AngularJS заполнители в строках обозначаются выражениями в двойных фигурных скобках.
//Интерполированные значения автоматически обновляются при изменении соответствующих свойств области видимости.
//<div>Сообщение: {{ message }}</div>

//-----------------------------------------
//__Использование выражений в атрибутах__//

//Задание по кодированию модуля 1//
/* 
Идея этого задания заключается в создании интерфейсного приложения, которое предоставляет пользователю текстовое поле, в котором они могут перечислять через запятую блюда, которые они обычно едят на обед. После ввода этого параметра пользователь должен нажать кнопку "Проверить, не слишком ли много".

Если количество элементов в текстовом поле меньше или равно 3 (например, 1, 2 или 3), под текстовым полем должно появиться сообщение "Наслаждайтесь!". Если количество элементов больше 3 (4, 5 и выше), под текстовым полем должно появиться сообщение "Слишком много!". (<em>Подсказка:</em> для реализации этого поведения вы можете использовать метод. <a>Смотрите документацию по этому методу</a>)split

Если текстовое поле пустое и пользователь нажимает кнопку "Проверить, не слишком ли много", должно появиться сообщение "Пожалуйста, сначала введите данные". 'Empty' здесь означает либо "" (пустая строка), либо строку, в которой есть только пробелы. (Подсказка: AngularJS ng-model уже выполняет обрезку за вас, поэтому вам не должно быть ничего, что нужно делать.)

В любой момент времени должно отображаться только 1 сообщение. Другими словами, если у вас одновременно отображаются оба сообщения: "Наслаждайтесь!" и "Слишком много!", это ошибка.

От вас не требуется обрабатывать случай, в котором между некоторыми запятыми нет элемента. Например, вы можете рассматривать этот случай item 1, item2,,item3 или this case item 1, item2, ,item3 как 4 элемента в списке. Однако вы можете реализовать проверку на наличие "пустого" элемента в качестве бонусной функции (без оценки). Пожалуйста, не забудьте поставить комментарий где-нибудь рядом с текстовым полем ввода, указав, что вы НЕ учитываете и освобождаете элемент, т.е. , , Как элемент для подсчета.
*/
/* 
<body ng-app="NameCalculator">
        <div ng-controller="NameCalculatorController">
            <h1>Name Calculator</h1>
            <input type="text" ng-model="name" >
            <button ng-click="getLenght(name)" >Проверить, не слишком ли много</button>
            <p>{{text}}</p>
        </div>
</body>
*/
(function () {
    'use strict';
    angular.module('NameCalculator', [])
        .controller('NameCalculatorController', function ($scope) {
            $scope.name = '';
            $scope.text = '';

            $scope.getLenght = (names) => {
                const splitNames = names.split(',').filter(el => el.length > 0).length
                if (splitNames === 0) {
                    $scope.text = 'Пожалуйста, сначала введите данные'
                } else if (splitNames <= 3) {
                    $scope.text = 'Наслаждайтесь!'
                } else if (splitNames > 3) {
                    $scope.text = 'Слишком много!'
                } else {
                    return
                }

            }
        });
})();

//------------------------------------------
//__